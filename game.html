<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#0A0A0A">
    <title>Playing - Gamex</title>
    <link rel="manifest" href="./manifest.json">
    <link rel="stylesheet" href="./styles/main.css">
</head>
<body>
    <div class="game-screen">
        <canvas id="auraCanvas"></canvas>

        <div class="content">
            <div class="game-header">
                <div class="round-counter">
                    Round <span id="currentRound">1</span> / <span id="totalRounds">8</span>
                </div>
                <div class="current-player" id="currentPlayerText">
                    Waiting...
                </div>
            </div>

            <!-- Emotion Choices (shown when it's player's turn) -->
            <div class="emotion-choices hidden" id="emotionChoices">
                <button class="emotion-btn love" data-emotion="love">
                    <div class="emotion-icon">‚ù§Ô∏è</div>
                    <div class="emotion-info">
                        <h3>Love</h3>
                        <p>Desire for connection and care.</p>
                    </div>
                </button>

                <button class="emotion-btn friendship" data-emotion="friendship">
                    <div class="emotion-icon">üíõ</div>
                    <div class="emotion-info">
                        <h3>Friendship</h3>
                        <p>Trust and stability.</p>
                    </div>
                </button>

                <button class="emotion-btn sex" data-emotion="sex">
                    <div class="emotion-icon">üíú</div>
                    <div class="emotion-info">
                        <h3>Sex</h3>
                        <p>Attraction and instinct.</p>
                    </div>
                </button>
            </div>

            <!-- Waiting State (shown when it's another player's turn) -->
            <div class="waiting-state" id="waitingState">
                <h3>Awaiting player's choice...</h3>
                <div class="spinner"></div>
                <p id="waitingPlayerText">Waiting for turn...</p>
            </div>
        </div>
    </div>

    <!-- PeerJS Library -->
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="./js/audio.js"></script>
    <script src="./js/animations.js"></script>
    <script src="./js/game-logic.js"></script>
    <script src="./js/peer-manager.js"></script>
    <script>
        const audio = new GameAudio();
        const canvas = document.getElementById('auraCanvas');
        const animations = new AuraAnimations(canvas);
        const gameLogic = new GameLogic();

        // Load game state
        let gameState = JSON.parse(sessionStorage.getItem('gameState'));
        if (!gameState) {
            window.location.href = './lobby.html';
        }

        // Check if PeerJS is active
        const isPeerActive = sessionStorage.getItem('peerManager') === 'active';
        if (!isPeerActive) {
            console.warn('PeerJS not active - running in offline mode');
        }

        // Initialize PeerManager
        const peerManager = new PeerManager();
        const localPlayer = gameState.players.find(p => p.isLocal);
        const isModerator = localPlayer && localPlayer.isModerator;

        // Reinitialize peer connection
        async function initializePeer() {
            if (!isPeerActive) return;

            try {
                await peerManager.initialize(localPlayer.name);

                // Restore connections if moderator
                if (isModerator) {
                    console.log('Moderator: Waiting for peer connections...');
                } else {
                    // Reconnect to moderator
                    const moderator = gameState.players.find(p => p.isModerator);
                    if (moderator) {
                        await peerManager.joinRoom(moderator.id);
                    }
                }
            } catch (error) {
                console.error('Failed to initialize peer:', error);
            }
        }

        // Update UI based on current turn
        function updateUI() {
            const currentRound = Math.floor(gameState.choices.length / gameState.players.length) + 1;
            document.getElementById('currentRound').textContent = currentRound;
            document.getElementById('totalRounds').textContent = gameState.totalRounds;

            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            const isLocalTurn = currentPlayer && currentPlayer.isLocal;

            if (isLocalTurn) {
                // Show choices
                document.getElementById('emotionChoices').classList.remove('hidden');
                document.getElementById('waitingState').classList.add('hidden');
                document.getElementById('currentPlayerText').textContent = 'Your turn';
                animations.setAuraType('ambient');

                // Enable buttons
                document.querySelectorAll('.emotion-btn').forEach(b => b.disabled = false);
            } else {
                // Show waiting state
                document.getElementById('emotionChoices').classList.add('hidden');
                document.getElementById('waitingState').classList.remove('hidden');
                document.getElementById('currentPlayerText').textContent =
                    currentPlayer ? `${currentPlayer.name}'s turn` : 'Waiting...';
                document.getElementById('waitingPlayerText').textContent =
                    currentPlayer ? `${currentPlayer.name} is choosing...` : 'Waiting...';
                animations.setAuraType('waiting');
            }
        }

        // Handle emotion choice
        function handleChoice(emotion, playerId) {
            const player = gameState.players.find(p => p.id === playerId);
            if (!player) return;

            const choice = {
                playerId: playerId,
                playerName: player.name,
                emotion: emotion,
                round: Math.floor(gameState.choices.length / gameState.players.length) + 1,
                turn: gameState.choices.length + 1
            };

            gameState.choices.push(choice);

            // Update averages
            gameLogic.updateAverages(gameState);

            // Play feedback
            audio.playSound(emotion);
            animations.playEmotionAnimation(emotion);
            if (navigator.vibrate) {
                navigator.vibrate(emotion === 'love' ? 20 : emotion === 'friendship' ? [10, 10, 10] : 30);
            }

            // Save state
            sessionStorage.setItem('gameState', JSON.stringify(gameState));

            // Move to next turn
            gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;

            // Broadcast next turn (moderator only)
            if (isModerator && isPeerActive) {
                peerManager.sendNextTurn(
                    gameState.currentPlayerIndex,
                    gameState.players[gameState.currentPlayerIndex].id
                );
            }

            // Check if game should end
            const minRoundsCompleted = Math.floor(gameState.choices.length / gameState.players.length);

            if (minRoundsCompleted >= gameState.totalRounds) {
                // Game over
                setTimeout(() => {
                    const result = gameLogic.checkBingo(gameState);

                    if (result.isBingo) {
                        animations.playBingoAnimation();
                        audio.playSound('bingo');
                        if (navigator.vibrate) navigator.vibrate([50, 100, 50]);
                    } else {
                        audio.playSound('replay');
                        if (navigator.vibrate) navigator.vibrate(200);
                    }

                    // Broadcast game over (moderator only)
                    if (isModerator && isPeerActive) {
                        peerManager.sendGameOver(result);
                    }

                    setTimeout(() => {
                        window.location.href = './results.html';
                    }, 2000);
                }, 1000);
            } else {
                // Continue game
                setTimeout(updateUI, 1500);
            }
        }

        // Emotion button handlers
        document.querySelectorAll('.emotion-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const emotion = this.dataset.emotion;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];

                if (!currentPlayer || !currentPlayer.isLocal) return;

                // Disable all buttons
                document.querySelectorAll('.emotion-btn').forEach(b => b.disabled = true);

                // Send choice via PeerJS
                if (isPeerActive) {
                    peerManager.sendChoice(emotion, gameState.choices.length + 1);
                }

                handleChoice(emotion, currentPlayer.id);
            });

            // Haptic feedback
            btn.addEventListener('touchstart', () => {
                if (navigator.vibrate && !btn.disabled) {
                    navigator.vibrate(10);
                }
            });
        });

        // PeerJS event handlers
        if (isPeerActive) {
            peerManager.on('choiceReceived', (data) => {
                console.log('Choice received:', data);

                // Only moderator processes all choices
                if (isModerator) {
                    handleChoice(data.emotion, data.playerId);
                }
            });

            peerManager.on('nextTurn', (data) => {
                console.log('Next turn:', data);

                // Update current player index
                gameState.currentPlayerIndex = data.currentPlayerIndex;
                sessionStorage.setItem('gameState', JSON.stringify(gameState));
                updateUI();
            });

            peerManager.on('gameOver', (result) => {
                console.log('Game over:', result);

                // Sync to results page
                setTimeout(() => {
                    window.location.href = './results.html';
                }, 2000);
            });

            // Initialize peer connection
            initializePeer();
        }

        // Initialize
        animations.startAmbientAura();
        updateUI();
    </script>
</body>
</html>
